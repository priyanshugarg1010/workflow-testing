# name: Update CHANGELOG on PR merge

# on:
#   pull_request:
#     types: [closed]
#     branches: [main]

# jobs:
#   update-changelog:
#     if: |
#       github.event.pull_request.merged == true &&
#       contains(github.event.pull_request.title, 'elease') &&
#       !contains(github.event.pull_request.title, 'nternal')
#     runs-on: ubuntu-latest
#     permissions:
#       contents: write
#       pull-requests: read

#     steps:
#       - name: Checkout main
#         uses: actions/checkout@v4
#         with:
#           ref: main
#           fetch-depth: 0

#       - name: Configure git
#         run: |
#           git config user.name "[bot] Changelog Updater"
#           git config user.email "changelog-bot@github.com"

#       - name: Extract current release version
#         id: current
#         run: |
#           TITLE="${{ github.event.pull_request.title }}"
#           NUMBER="${{ github.event.pull_request.number }}"
#           URL="${{ github.event.pull_request.html_url }}"
          
#           # Extract version number
#           VERSION=$(echo "$TITLE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+')
          
#           # Extract major.minor (e.g., 2.2154 from 2.2154.009+3467)
#           MAJOR_MINOR=$(echo "$VERSION" | grep -oE '^[0-9]+\.[0-9]+')
          
#           echo "version=$VERSION" >> $GITHUB_OUTPUT
#           echo "major_minor=$MAJOR_MINOR" >> $GITHUB_OUTPUT
#           echo "number=$NUMBER" >> $GITHUB_OUTPUT
#           echo "url=$URL" >> $GITHUB_OUTPUT
          
#           echo "Current Release: $VERSION"
#           echo "Major.Minor: $MAJOR_MINOR"

#       - name: Find previous release and collect PRs
#         id: collect
#         env:
#           GH_TOKEN: ${{ github.token }}
#         run: |
#           CURRENT_PR_NUMBER="${{ steps.current.outputs.number }}"
#           CURRENT_VERSION="${{ steps.current.outputs.version }}"
#           CURRENT_MAJOR_MINOR="${{ steps.current.outputs.major_minor }}"
          
#           echo "Searching for previous release PR..."
          
#           # Get all merged PRs to main, sorted by merge date (newest first)
#           PREVIOUS_RELEASE_PR=""
#           PREVIOUS_VERSION=""
#           PREVIOUS_MAJOR_MINOR=""
          
#           # Search for the most recent release PR before current one
#           gh pr list \
#             --state merged \
#             --base main \
#             --limit 100 \
#             --json number,title,mergedAt,url \
#             --jq 'sort_by(.mergedAt) | reverse | .[] | select(.number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > prs.txt
          
#           while IFS='|' read -r pr_num pr_title pr_url; do
#             # Check if this PR is a release PR (not internal)
#             if [[ "$pr_title" =~ ^[Rr][Ee][Ll][Ee][Aa][Ss][Ee] ]] && ! [[ "$pr_title" =~ ^[Ii][Nn][Tt][Ee][Rr][Nn][Aa][Ll] ]]; then
#               PREVIOUS_RELEASE_PR="$pr_num"
#               PREVIOUS_VERSION=$(echo "$pr_title" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+')
#               PREVIOUS_MAJOR_MINOR=$(echo "$PREVIOUS_VERSION" | grep -oE '^[0-9]+\.[0-9]+')
#               echo "Found previous release: PR #$PREVIOUS_RELEASE_PR - $PREVIOUS_VERSION"
#               break
#             fi
#           done < prs.txt
          
#           # Determine if this is a new major/minor version
#           if [ -z "$PREVIOUS_MAJOR_MINOR" ]; then
#             echo "is_new_version=true" >> $GITHUB_OUTPUT
#             echo "This is the first release"
#           elif [ "$CURRENT_MAJOR_MINOR" != "$PREVIOUS_MAJOR_MINOR" ]; then
#             echo "is_new_version=true" >> $GITHUB_OUTPUT
#             echo "New version detected: $PREVIOUS_MAJOR_MINOR -> $CURRENT_MAJOR_MINOR"
#           else
#             echo "is_new_version=false" >> $GITHUB_OUTPUT
#             echo "Same version family: $CURRENT_MAJOR_MINOR"
#           fi
          
#           echo "previous_pr=$PREVIOUS_RELEASE_PR" >> $GITHUB_OUTPUT
#           echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT

#       - name: Collect PRs for this version
#         id: prs
#         env:
#           GH_TOKEN: ${{ github.token }}
#         run: |
#           CURRENT_PR_NUMBER="${{ steps.current.outputs.number }}"
#           CURRENT_MAJOR_MINOR="${{ steps.current.outputs.major_minor }}"
#           IS_NEW_VERSION="${{ steps.collect.outputs.is_new_version }}"
          
#           echo "Collecting PRs for version $CURRENT_MAJOR_MINOR..."
          
#           # If this is a NEW version, only get PRs since last release
#           # If SAME version, get ALL PRs for this version from the beginning
          
#           if [ "$IS_NEW_VERSION" = "true" ]; then
#             # NEW VERSION: Get PRs between last release and current
#             PREVIOUS_PR_NUMBER="${{ steps.collect.outputs.previous_pr }}"
#             echo "New version - collecting PRs since #$PREVIOUS_PR_NUMBER"
            
#             if [ -n "$PREVIOUS_PR_NUMBER" ]; then
#               gh pr list \
#                 --state merged \
#                 --base main \
#                 --limit 500 \
#                 --json number,title,url \
#                 --jq '.[] | select(.number > '$PREVIOUS_PR_NUMBER' and .number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > between_prs.txt
#             else
#               # First release ever
#               gh pr list \
#                 --state merged \
#                 --base main \
#                 --limit 500 \
#                 --json number,title,url \
#                 --jq '.[] | select(.number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > between_prs.txt
#             fi
#           else
#             # SAME VERSION: Need to get ALL PRs for this entire version family
#             echo "Same version - collecting ALL PRs for version $CURRENT_MAJOR_MINOR"
            
#             # Find the FIRST release PR for this major.minor version
#             FIRST_RELEASE_PR=""
#             gh pr list \
#               --state merged \
#               --base main \
#               --limit 500 \
#               --json number,title,mergedAt \
#               --jq 'sort_by(.mergedAt) | .[] | "\(.number)|\(.title)"' > all_prs.txt
            
#             while IFS='|' read -r pr_num pr_title; do
#               if [[ "$pr_title" =~ ^[Rr][Ee][Ll][Ee][Aa][Ss][Ee] ]] && ! [[ "$pr_title" =~ ^[Ii][Nn][Tt][Ee][Rr][Nn][Aa][Ll] ]]; then
#                 VERSION=$(echo "$pr_title" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+')
#                 MAJOR_MINOR=$(echo "$VERSION" | grep -oE '^[0-9]+\.[0-9]+')
                
#                 if [ "$MAJOR_MINOR" = "$CURRENT_MAJOR_MINOR" ]; then
#                   FIRST_RELEASE_PR="$pr_num"
#                   echo "Found first release for $CURRENT_MAJOR_MINOR: PR #$FIRST_RELEASE_PR"
#                   break
#                 fi
#               fi
#             done < all_prs.txt
            
#             # Get all PRs from first release of this version to current
#             if [ -n "$FIRST_RELEASE_PR" ]; then
#               gh pr list \
#                 --state merged \
#                 --base main \
#                 --limit 500 \
#                 --json number,title,url \
#                 --jq '.[] | select(.number > '$FIRST_RELEASE_PR' and .number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > between_prs.txt
#             else
#               # Fallback: get PRs from last release
#               PREVIOUS_PR_NUMBER="${{ steps.collect.outputs.previous_pr }}"
#               gh pr list \
#                 --state merged \
#                 --base main \
#                 --limit 500 \
#                 --json number,title,url \
#                 --jq '.[] | select(.number > '$PREVIOUS_PR_NUMBER' and .number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > between_prs.txt
#             fi
#           fi
          
#           # Filter out internal PRs and collect normal PRs
#           > normal_prs.txt  # Create empty file
          
#           while IFS='|' read -r pr_num pr_title pr_url; do
#             # Skip internal PRs
#             if [[ "$pr_title" =~ ^[Ii][Nn][Tt][Ee][Rr][Nn][Aa][Ll] ]]; then
#               echo "Skipping internal PR #$pr_num: $pr_title"
#               continue
#             fi
            
#             # Skip release PRs
#             if [[ "$pr_title" =~ ^[Rr][Ee][Ll][Ee][Aa][Ss][Ee] ]]; then
#               continue
#             fi
            
#             # Add to file (one per line)
#             echo "$pr_num|$pr_title|$pr_url" >> normal_prs.txt
#           done < between_prs.txt
          
#           # Count PRs
#           PR_COUNT=$(wc -l < normal_prs.txt | tr -d ' ')
#           echo "Found $PR_COUNT normal PRs"
#           echo "pr_count=$PR_COUNT" >> $GITHUB_OUTPUT

#       - name: Update CHANGELOG.md
#         run: |
#           CURRENT_VERSION="${{ steps.current.outputs.version }}"
#           CURRENT_PR_URL="${{ steps.current.outputs.url }}"
#           CURRENT_MAJOR_MINOR="${{ steps.current.outputs.major_minor }}"
#           IS_NEW_VERSION="${{ steps.collect.outputs.is_new_version }}"
#           PREVIOUS_VERSION="${{ steps.collect.outputs.previous_version }}"
#           REPO="${{ github.repository }}"
          
#           # Create CHANGELOG.md if it doesn't exist
#           if [ ! -f CHANGELOG.md ]; then
#             echo "# Changelog" > CHANGELOG.md
#             echo "" >> CHANGELOG.md
#           fi
          
#           export CURRENT_VERSION
#           export CURRENT_PR_URL
#           export IS_NEW_VERSION
#           export PREVIOUS_VERSION
#           export REPO
          
#           python3 << 'PYTHON_SCRIPT'
#           import re
#           import os
          
#           current_version = os.environ.get('CURRENT_VERSION')
#           current_pr_url = os.environ.get('CURRENT_PR_URL')
#           is_new_version = os.environ.get('IS_NEW_VERSION')
#           previous_version = os.environ.get('PREVIOUS_VERSION')
#           repo = os.environ.get('REPO')
          
#           # Read the CHANGELOG
#           with open('CHANGELOG.md', 'r') as f:
#               content = f.read()
          
#           # Read the collected PRs
#           pr_entries = []
#           try:
#               with open('normal_prs.txt', 'r') as f:
#                   for line in f:
#                       line = line.strip()
#                       if not line:
#                           continue
#                       parts = line.split('|')
#                       if len(parts) >= 3:
#                           pr_num = parts[0]
#                           pr_url = parts[2]
#                           pr_title = '|'.join(parts[1:-1]) if len(parts) > 3 else parts[1]
#                           pr_entries.append(f"- [#{pr_num}]({pr_url}) {pr_title}")
#           except FileNotFoundError:
#               pass
          
#           # Reverse to show newest first
#           pr_entries.reverse()
          
#           # Extract major.minor for the version label
#           major_minor = '.'.join(current_version.split('.')[:2])
          
#           # Check if this is a new major.minor version
#           if is_new_version == 'true':
#               # Create NEW version section with heading format: ### [version](url) Version X.Y
#               new_section = f"### [{current_version}]({current_pr_url}) Version {major_minor}\n"
#               if pr_entries:
#                   new_section += "\n".join(pr_entries) + "\n"
              
#               # Check if we already have content
#               if content.strip() == "# Changelog":
#                   # First release
#                   content = f"# Changelog\n\n{new_section}\n"
#               else:
#                   # Insert after the title
#                   content = re.sub(
#                       r'(# Changelog\s*\n)',
#                       r'\1\n' + new_section + '\n',
#                       content,
#                       count=1
#                   )
#           else:
#               # Same major.minor version - REPLACE existing section with updated data
#               # The workflow already collected ALL PRs for this version, so just replace
#               version_pattern = rf'### \[[^\]]+\]\([^)]+\) Version {re.escape(major_minor)}'
              
#               # Build the updated section with all PRs
#               updated_section = f"### [{current_version}]({current_pr_url}) Version {major_minor}\n"
#               if pr_entries:
#                   updated_section += "\n".join(pr_entries) + "\n"
              
#               if re.search(version_pattern, content):
#                   # Replace the existing section completely
#                   content = re.sub(
#                       rf'### \[[^\]]+\]\([^)]+\) Version {re.escape(major_minor)}\n(?:- \[.*?\n)*',
#                       updated_section,
#                       content,
#                       count=1
#                   )
#               else:
#                   # Version section doesn't exist, create it
#                   content = re.sub(
#                       r'(# Changelog\s*\n)',
#                       r'\1\n' + updated_section + '\n',
#                       content,
#                       count=1
#                   )
          
#           with open('CHANGELOG.md', 'w') as f:
#               f.write(content)
          
#           print(f"✓ Added release {current_version} with {len(pr_entries)} PRs")
#           PYTHON_SCRIPT

#       - name: Commit and push changes
#         run: |
#           git add CHANGELOG.md
          
#           # Check if there are changes to commit
#           if git diff --staged --quiet; then
#             echo "No changes to commit"
#             exit 0
#           fi
          
#           git commit -m "chore: update CHANGELOG for release ${{ steps.current.outputs.version }}" -m "Co-Authored-By: Warp <agent@warp.dev>"
          
#           # Only push if not running in act (local testing)
#           if [ -z "$ACT" ]; then
#             git push origin main
#           else
#             echo "Running in act - skipping push"
#             echo "Changes committed locally:"
#             git log -1 --stat
#           fi

name: Update CHANGELOG on PR merge

on:
  pull_request:
    types: [closed]
    branches: [main]

jobs:
  update-changelog:
    if: |
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.title, 'elease') &&
      !contains(github.event.pull_request.title, 'nternal')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "[bot] Changelog Updater"
          git config user.email "changelog-bot@github.com"

      - name: Extract current release version
        id: current
        run: |
          TITLE="${{ github.event.pull_request.title }}"
          NUMBER="${{ github.event.pull_request.number }}"
          URL="${{ github.event.pull_request.html_url }}"
          
          # Extract version number
          VERSION=$(echo "$TITLE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+')
          
          # Extract major.minor (e.g., 2.2154 from 2.2154.009+3467)
          MAJOR_MINOR=$(echo "$VERSION" | grep -oE '^[0-9]+\.[0-9]+')
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "major_minor=$MAJOR_MINOR" >> $GITHUB_OUTPUT
          echo "number=$NUMBER" >> $GITHUB_OUTPUT
          echo "url=$URL" >> $GITHUB_OUTPUT
          
          echo "Current Release: $VERSION"
          echo "Major.Minor: $MAJOR_MINOR"

      - name: Find previous release and collect PRs
        id: collect
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CURRENT_PR_NUMBER="${{ steps.current.outputs.number }}"
          CURRENT_VERSION="${{ steps.current.outputs.version }}"
          CURRENT_MAJOR_MINOR="${{ steps.current.outputs.major_minor }}"
          
          echo "Searching for previous release PR..."
          
          # Get all merged PRs to main, sorted by merge date (newest first)
          PREVIOUS_RELEASE_PR=""
          PREVIOUS_VERSION=""
          PREVIOUS_MAJOR_MINOR=""
          
          # Search for the most recent release PR before current one
          gh pr list \
            --state merged \
            --base main \
            --limit 100 \
            --json number,title,mergedAt,url \
            --jq 'sort_by(.mergedAt) | reverse | .[] | select(.number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > prs.txt
          
          while IFS='|' read -r pr_num pr_title pr_url; do
            # Check if this PR is a release PR (not internal)
            if [[ "$pr_title" =~ ^[Rr][Ee][Ll][Ee][Aa][Ss][Ee] ]] && ! [[ "$pr_title" =~ ^[Ii][Nn][Tt][Ee][Rr][Nn][Aa][Ll] ]]; then
              PREVIOUS_RELEASE_PR="$pr_num"
              PREVIOUS_VERSION=$(echo "$pr_title" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+')
              PREVIOUS_MAJOR_MINOR=$(echo "$PREVIOUS_VERSION" | grep -oE '^[0-9]+\.[0-9]+')
              echo "Found previous release: PR #$PREVIOUS_RELEASE_PR - $PREVIOUS_VERSION"
              break
            fi
          done < prs.txt
          
          # Determine if this is a new major/minor version
          if [ -z "$PREVIOUS_MAJOR_MINOR" ]; then
            echo "is_new_version=true" >> $GITHUB_OUTPUT
            echo "This is the first release"
          elif [ "$CURRENT_MAJOR_MINOR" != "$PREVIOUS_MAJOR_MINOR" ]; then
            echo "is_new_version=true" >> $GITHUB_OUTPUT
            echo "New version detected: $PREVIOUS_MAJOR_MINOR -> $CURRENT_MAJOR_MINOR"
          else
            echo "is_new_version=false" >> $GITHUB_OUTPUT
            echo "Same version family: $CURRENT_MAJOR_MINOR"
          fi
          
          echo "previous_pr=$PREVIOUS_RELEASE_PR" >> $GITHUB_OUTPUT
          echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT

      - name: Collect PRs between releases
        id: prs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CURRENT_PR_NUMBER="${{ steps.current.outputs.number }}"
          PREVIOUS_PR_NUMBER="${{ steps.collect.outputs.previous_pr }}"
          
          echo "Collecting PRs between #$PREVIOUS_PR_NUMBER and #$CURRENT_PR_NUMBER..."
          
          # Get all PRs between previous and current release with labels and merge date
          if [ -n "$PREVIOUS_PR_NUMBER" ]; then
            gh pr list \
              --state merged \
              --base main \
              --limit 500 \
              --json number,title,url,labels,mergedAt \
              --jq '.[] | select(.number > '$PREVIOUS_PR_NUMBER' and .number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)|\(.labels | map(.name) | join(","))|\(.mergedAt)"' > between_prs.txt
          else
            # No previous release, get all PRs before current
            gh pr list \
              --state merged \
              --base main \
              --limit 500 \
              --json number,title,url,labels,mergedAt \
              --jq '.[] | select(.number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)|\(.labels | map(.name) | join(","))|\(.mergedAt)"' > between_prs.txt
          fi
          
          # Filter out internal PRs and collect normal PRs
          NORMAL_PRS=""
          while IFS='|' read -r pr_num pr_title pr_url pr_labels pr_merged_at; do
            # Skip internal PRs
            if [[ "$pr_title" =~ ^[Ii][Nn][Tt][Ee][Rr][Nn][Aa][Ll] ]]; then
              echo "Skipping internal PR #$pr_num: $pr_title"
              continue
            fi
            
            # Skip release PRs
            if [[ "$pr_title" =~ ^[Rr][Ee][Ll][Ee][Aa][Ss][Ee] ]]; then
              continue
            fi
            
            # Add to list
            if [ -z "$NORMAL_PRS" ]; then
              NORMAL_PRS="$pr_num|$pr_title|$pr_url|$pr_labels|$pr_merged_at"
            else
              NORMAL_PRS="${NORMAL_PRS}${pr_num}|${pr_title}|${pr_url}|${pr_labels}|${pr_merged_at}"
            fi
          done < between_prs.txt
          
          # Save PR list to file for next step
          echo "$NORMAL_PRS" > normal_prs.txt
          
          PR_COUNT=$(echo "$NORMAL_PRS" | grep -c '|' || echo "0")
          echo "Found $PR_COUNT normal PRs"
          echo "pr_count=$PR_COUNT" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG.md
        run: |
          CURRENT_VERSION="${{ steps.current.outputs.version }}"
          CURRENT_PR_URL="${{ steps.current.outputs.url }}"
          CURRENT_MAJOR_MINOR="${{ steps.current.outputs.major_minor }}"
          IS_NEW_VERSION="${{ steps.collect.outputs.is_new_version }}"
          PREVIOUS_VERSION="${{ steps.collect.outputs.previous_version }}"
          REPO="${{ github.repository }}"
          
          # Create CHANGELOG.md if it doesn't exist
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          export CURRENT_VERSION
          export CURRENT_PR_URL
          export IS_NEW_VERSION
          export PREVIOUS_VERSION
          export REPO
          
          python3 << 'PYTHON_SCRIPT'
          import re
          import os
          from datetime import datetime
          from collections import defaultdict
          
          current_version = os.environ.get('CURRENT_VERSION')
          current_pr_url = os.environ.get('CURRENT_PR_URL')
          is_new_version = os.environ.get('IS_NEW_VERSION')
          previous_version = os.environ.get('PREVIOUS_VERSION')
          repo = os.environ.get('REPO')
          
          # Label to category mapping
          CATEGORY_MAP = {
              'bug-fix': 'Bug Fixes',
              'bug': 'Bug Fixes',
              'bugfix': 'Bug Fixes',
              'feature': 'Features',
              'enhancement': 'Features',
              'refactor': 'Refactors',
              'update': 'Updates',
              'updates': 'Updates',
              'documentation': 'Updates',
              'docs': 'Updates'
          }
          
          def categorize_pr(labels):
              """Determine category based on labels"""
              if not labels:
                  return 'Updates'
              
              labels_lower = [l.lower() for l in labels.split(',') if l]
              
              for label in labels_lower:
                  if label in CATEGORY_MAP:
                      return CATEGORY_MAP[label]
              
              return 'Updates'
          
          def format_date(iso_date):
              """Format ISO date to DD/MM/YY"""
              try:
                  dt = datetime.fromisoformat(iso_date.replace('Z', '+00:00'))
                  return dt.strftime('%d/%m/%y')
              except:
                  return ''
          
          # Read the CHANGELOG
          with open('CHANGELOG.md', 'r') as f:
              content = f.read()
          
          # Read and categorize PRs
          categorized_prs = defaultdict(list)
          try:
              with open('normal_prs.txt', 'r') as f:
                  for line in f:
                      line = line.strip()
                      if not line:
                          continue
                      parts = line.split('|')
                      if len(parts) >= 5:
                          pr_num, pr_title, pr_url, pr_labels, pr_merged_at = parts[:5]
                          category = categorize_pr(pr_labels)
                          date_str = format_date(pr_merged_at)
                          entry = f"- {date_str} - [#{pr_num}]({pr_url}) {pr_title}"
                          categorized_prs[category].append(entry)
          except FileNotFoundError:
              pass
          
          # Sort categories in desired order
          category_order = ['Features', 'Bug Fixes', 'Refactors', 'Updates']
          
          # Build the PR section
          pr_section = ""
          for category in category_order:
              if category in categorized_prs:
                  # Sort entries by date (newest first) within each category
                  entries = sorted(categorized_prs[category], reverse=True)
                  pr_section += f"\n**{category}**\n"
                  pr_section += "\n".join(entries) + "\n"
          
          # Extract major.minor for the version label
          major_minor = '.'.join(current_version.split('.')[:2])
          
          # Check if this is a new major.minor version
          if is_new_version == 'true':
              # Create NEW version section
              new_section = f"### [{current_version}]({current_pr_url}) Version {major_minor}\n"
              if pr_section:
                  new_section += pr_section
              
              # Check if we already have content
              if content.strip() == "# Changelog":
                  # First release
                  content = f"# Changelog\n\n{new_section}\n"
              else:
                  # Insert after the title
                  content = re.sub(
                      r'(# Changelog\s*\n)',
                      r'\1\n' + new_section + '\n',
                      content,
                      count=1
                  )
          else:
              # Same major.minor version - UPDATE existing section
              version_pattern = rf'### \[[^\]]+\]\([^)]+\) Version {re.escape(major_minor)}'
              
              if re.search(version_pattern, content):
                  # Extract existing PRs from the section
                  section_match = re.search(
                      rf'(### \[[^\]]+\]\([^)]+\) Version {re.escape(major_minor)}\n)(.*?)(?=\n### |\Z)',
                      content,
                      re.DOTALL
                  )
                  
                  existing_section = ""
                  if section_match and section_match.group(2):
                      existing_section = section_match.group(2).strip()
                  
                  # Parse existing categorized entries
                  existing_categorized = defaultdict(list)
                  current_category = None
                  for line in existing_section.split('\n'):
                      if line.startswith('**') and line.endswith('**'):
                          current_category = line.strip('*')
                      elif line.startswith('- ') and current_category:
                          existing_categorized[current_category].append(line)
                  
                  # Merge with new entries
                  for category, entries in categorized_prs.items():
                      existing_categorized[category].extend(entries)
                  
                  # Rebuild section with merged entries
                  merged_section = ""
                  for category in category_order:
                      if category in existing_categorized:
                          # Remove duplicates and sort
                          unique_entries = list(dict.fromkeys(existing_categorized[category]))
                          sorted_entries = sorted(unique_entries, reverse=True)
                          merged_section += f"\n**{category}**\n"
                          merged_section += "\n".join(sorted_entries) + "\n"
                  
                  # Build updated section
                  updated_section = f"### [{current_version}]({current_pr_url}) Version {major_minor}\n{merged_section}"
                  
                  # Replace the old section
                  content = re.sub(
                      rf'### \[[^\]]+\]\([^)]+\) Version {re.escape(major_minor)}\n.*?(?=\n### |\Z)',
                      updated_section,
                      content,
                      count=1,
                      flags=re.DOTALL
                  )
              else:
                  # Version section doesn't exist, create it
                  new_section = f"### [{current_version}]({current_pr_url}) Version {major_minor}\n"
                  if pr_section:
                      new_section += pr_section
                  
                  content = re.sub(
                      r'(# Changelog\s*\n)',
                      r'\1\n' + new_section + '\n',
                      content,
                      count=1
                  )
          
          with open('CHANGELOG.md', 'w') as f:
              f.write(content)
          
          total_prs = sum(len(entries) for entries in categorized_prs.values())
          print(f"✓ Added release {current_version} with {total_prs} PRs")
          PYTHON_SCRIPT

      - name: Commit and push changes
        run: |
          git add CHANGELOG.md
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          git commit -m "chore: update CHANGELOG for release ${{ steps.current.outputs.version }}" -m "Co-Authored-By: Warp <agent@warp.dev>"
          
          # Only push if not running in act (local testing)
          if [ -z "$ACT" ]; then
            git push origin main
          else
            echo "Running in act - skipping push"
            echo "Changes committed locally:"
            git log -1 --stat
          fi