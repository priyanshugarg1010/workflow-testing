name: Update CHANGELOG on PR merge

on:
  pull_request:
    types: [closed]
    branches: [main]

jobs:
  update-changelog:
    if: |
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.title, 'elease') &&
      !contains(github.event.pull_request.title, 'nternal')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "[bot] Changelog Updater"
          git config user.email "changelog-bot@github.com"

      - name: Extract current release version
        id: current
        run: |
          TITLE="${{ github.event.pull_request.title }}"
          NUMBER="${{ github.event.pull_request.number }}"
          URL="${{ github.event.pull_request.html_url }}"
          
          # Extract version number
          VERSION=$(echo "$TITLE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+')
          
          # Extract major.minor (e.g., 2.2154 from 2.2154.009+3467)
          MAJOR_MINOR=$(echo "$VERSION" | grep -oE '^[0-9]+\.[0-9]+')
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "major_minor=$MAJOR_MINOR" >> $GITHUB_OUTPUT
          echo "number=$NUMBER" >> $GITHUB_OUTPUT
          echo "url=$URL" >> $GITHUB_OUTPUT
          
          echo "Current Release: $VERSION"
          echo "Major.Minor: $MAJOR_MINOR"

      - name: Find previous release and collect PRs
        id: collect
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CURRENT_PR_NUMBER="${{ steps.current.outputs.number }}"
          CURRENT_VERSION="${{ steps.current.outputs.version }}"
          CURRENT_MAJOR_MINOR="${{ steps.current.outputs.major_minor }}"
          
          echo "Searching for previous release PR..."
          
          # Get all merged PRs to main, sorted by merge date (newest first)
          PREVIOUS_RELEASE_PR=""
          PREVIOUS_VERSION=""
          PREVIOUS_MAJOR_MINOR=""
          
          # Search for the most recent release PR before current one
          gh pr list \
            --state merged \
            --base main \
            --limit 100 \
            --json number,title,mergedAt,url \
            --jq 'sort_by(.mergedAt) | reverse | .[] | select(.number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > prs.txt
          
          while IFS='|' read -r pr_num pr_title pr_url; do
            # Check if this PR is a release PR (not internal)
            if [[ "$pr_title" =~ ^[Rr][Ee][Ll][Ee][Aa][Ss][Ee] ]] && ! [[ "$pr_title" =~ ^[Ii][Nn][Tt][Ee][Rr][Nn][Aa][Ll] ]]; then
              PREVIOUS_RELEASE_PR="$pr_num"
              PREVIOUS_VERSION=$(echo "$pr_title" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+')
              PREVIOUS_MAJOR_MINOR=$(echo "$PREVIOUS_VERSION" | grep -oE '^[0-9]+\.[0-9]+')
              echo "Found previous release: PR #$PREVIOUS_RELEASE_PR - $PREVIOUS_VERSION"
              break
            fi
          done < prs.txt
          
          # Determine if this is a new major/minor version
          if [ -z "$PREVIOUS_MAJOR_MINOR" ]; then
            echo "is_new_version=true" >> $GITHUB_OUTPUT
            echo "This is the first release"
          elif [ "$CURRENT_MAJOR_MINOR" != "$PREVIOUS_MAJOR_MINOR" ]; then
            echo "is_new_version=true" >> $GITHUB_OUTPUT
            echo "New version detected: $PREVIOUS_MAJOR_MINOR -> $CURRENT_MAJOR_MINOR"
          else
            echo "is_new_version=false" >> $GITHUB_OUTPUT
            echo "Same version family: $CURRENT_MAJOR_MINOR"
          fi
          
          echo "previous_pr=$PREVIOUS_RELEASE_PR" >> $GITHUB_OUTPUT
          echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT

      - name: Collect PRs between releases
        id: prs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CURRENT_PR_NUMBER="${{ steps.current.outputs.number }}"
          PREVIOUS_PR_NUMBER="${{ steps.collect.outputs.previous_pr }}"
          
          echo "Collecting PRs between #$PREVIOUS_PR_NUMBER and #$CURRENT_PR_NUMBER..."
          
          # Get all PRs between previous and current release
          PR_LIST=""
          
          if [ -n "$PREVIOUS_PR_NUMBER" ]; then
            gh pr list \
              --state merged \
              --base main \
              --limit 500 \
              --json number,title,url \
              --jq '.[] | select(.number > '$PREVIOUS_PR_NUMBER' and .number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > between_prs.txt
          else
            # No previous release, get all PRs before current
            gh pr list \
              --state merged \
              --base main \
              --limit 500 \
              --json number,title,url \
              --jq '.[] | select(.number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > between_prs.txt
          fi
          
          # Filter out internal PRs and collect normal PRs
          NORMAL_PRS=""
          while IFS='|' read -r pr_num pr_title pr_url; do
            # Skip internal PRs
            if [[ "$pr_title" =~ ^[Ii][Nn][Tt][Ee][Rr][Nn][Aa][Ll] ]]; then
              echo "Skipping internal PR #$pr_num: $pr_title"
              continue
            fi
            
            # Skip release PRs
            if [[ "$pr_title" =~ ^[Rr][Ee][Ll][Ee][Aa][Ss][Ee] ]]; then
              continue
            fi
            
            # Add to list
            if [ -z "$NORMAL_PRS" ]; then
              NORMAL_PRS="$pr_num|$pr_title|$pr_url"
            else
              NORMAL_PRS="${NORMAL_PRS}{pr_num}|${pr_title}|${pr_url}"
            fi
          done < between_prs.txt
          
          # Save PR list to file for next step
          echo "$NORMAL_PRS" > normal_prs.txt
          
          PR_COUNT=$(echo "$NORMAL_PRS" | grep -c '|' || echo "0")
          echo "Found $PR_COUNT normal PRs"
          echo "pr_count=$PR_COUNT" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG.md
        run: |
          CURRENT_VERSION="${{ steps.current.outputs.version }}"
          CURRENT_PR_URL="${{ steps.current.outputs.url }}"
          CURRENT_MAJOR_MINOR="${{ steps.current.outputs.major_minor }}"
          IS_NEW_VERSION="${{ steps.collect.outputs.is_new_version }}"
          PREVIOUS_VERSION="${{ steps.collect.outputs.previous_version }}"
          REPO="${{ github.repository }}"
          
          # Create CHANGELOG.md if it doesn't exist
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          export CURRENT_VERSION
          export CURRENT_PR_URL
          export IS_NEW_VERSION
          export PREVIOUS_VERSION
          export REPO
          
          python3 << 'PYTHON_SCRIPT'
          import re
          import os
          
          current_version = os.environ.get('CURRENT_VERSION')
          current_pr_url = os.environ.get('CURRENT_PR_URL')
          is_new_version = os.environ.get('IS_NEW_VERSION')
          previous_version = os.environ.get('PREVIOUS_VERSION')
          repo = os.environ.get('REPO')
          
          # Read the CHANGELOG
          with open('CHANGELOG.md', 'r') as f:
              content = f.read()
          
          # Read the collected PRs
          pr_entries = []
          try:
              with open('normal_prs.txt', 'r') as f:
                  for line in f:
                      line = line.strip()
                      if not line:
                          continue
                      parts = line.split('|')
                      if len(parts) == 3:
                          pr_num, pr_title, pr_url = parts
                          pr_entries.append(f"- [{repo}#{pr_num}]({pr_url}) {pr_title}")
          except FileNotFoundError:
              pass
          
          # Reverse to show newest first
          pr_entries.reverse()
          
          # Extract major.minor for the version label
          major_minor = '.'.join(current_version.split('.')[:2])
          
          # Check if this is a new major.minor version
          if is_new_version == 'true':
              # Create NEW version section with heading format: ### [version](url) Version X.Y
              new_section = f"### [{current_version}]({current_pr_url}) Version {major_minor}\n"
              if pr_entries:
                  new_section += "\n".join(pr_entries) + "\n"
              
              # Check if we already have content
              if content.strip() == "# Changelog":
                  # First release
                  content = f"# Changelog\n\n{new_section}\n"
              else:
                  # Insert after the title
                  content = re.sub(
                      r'(# Changelog\s*\n)',
                      r'\1\n' + new_section + '\n',
                      content,
                      count=1
                  )
          else:
              # Same major.minor version - UPDATE existing section
              # Find the existing version section heading
              version_pattern = rf'### \[[^\]]+\]\([^)]+\) Version {re.escape(major_minor)}'
              
              if re.search(version_pattern, content):
                  # Extract existing PRs from the section
                  section_match = re.search(
                      rf'(### \[[^\]]+\]\([^)]+\) Version {re.escape(major_minor)}\n)((?:- \[.*?\n)*)',
                      content
                  )
                  
                  existing_prs = []
                  if section_match and section_match.group(2):
                      existing_prs = section_match.group(2).strip().split('\n')
                  
                  # Combine existing PRs with new PRs
                  all_prs = pr_entries + existing_prs
                  
                  # Build updated section with new version link and all PRs
                  updated_section = f"### [{current_version}]({current_pr_url}) Version {major_minor}\n"
                  if all_prs:
                      updated_section += "\n".join(all_prs) + "\n"
                  
                  # Replace the old section with updated one
                  content = re.sub(
                      rf'### \[[^\]]+\]\([^)]+\) Version {re.escape(major_minor)}\n(?:- \[.*?\n)*',
                      updated_section,
                      content,
                      count=1
                  )
              else:
                  # Version section doesn't exist, create it
                  new_section = f"### [{current_version}]({current_pr_url}) Version {major_minor}\n"
                  if pr_entries:
                      new_section += "\n".join(pr_entries) + "\n"
                  
                  content = re.sub(
                      r'(# Changelog\s*\n)',
                      r'\1\n' + new_section + '\n',
                      content,
                      count=1
                  )
          
          with open('CHANGELOG.md', 'w') as f:
              f.write(content)
          
          print(f"âœ“ Added release {current_version} with {len(pr_entries)} PRs")
          PYTHON_SCRIPT

      - name: Commit and push changes
        run: |
          git add CHANGELOG.md
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          git commit -m "chore: update CHANGELOG for release ${{ steps.current.outputs.version }}" -m "Co-Authored-By: Warp <agent@warp.dev>"
          
          # Only push if not running in act (local testing)
          if [ -z "$ACT" ]; then
            git push origin main
          else
            echo "Running in act - skipping push"
            echo "Changes committed locally:"
            git log -1 --stat
          fi
