name: Update CHANGELOG on PR merge

on:
  pull_request:
    types: [closed]
    branches: [main]

jobs:
  update-changelog:
    if: |
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.title, 'elease') &&
      !contains(github.event.pull_request.title, 'nternal')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "[bot] Changelog Updater"
          git config user.email "changelog-bot@github.com"

      - name: Extract current release version
        id: current
        run: |
          TITLE="${{ github.event.pull_request.title }}"
          NUMBER="${{ github.event.pull_request.number }}"
          URL="${{ github.event.pull_request.html_url }}"
          
          # Extract version number
          VERSION=$(echo "$TITLE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+')
          
          # Extract major.minor (e.g., 2.2154 from 2.2154.009+3467)
          MAJOR_MINOR=$(echo "$VERSION" | grep -oE '^[0-9]+\.[0-9]+')
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "major_minor=$MAJOR_MINOR" >> $GITHUB_OUTPUT
          echo "number=$NUMBER" >> $GITHUB_OUTPUT
          echo "url=$URL" >> $GITHUB_OUTPUT
          
          echo "Current Release: $VERSION"
          echo "Major.Minor: $MAJOR_MINOR"

      - name: Find previous release and collect PRs
        id: collect
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CURRENT_PR_NUMBER="${{ steps.current.outputs.number }}"
          CURRENT_VERSION="${{ steps.current.outputs.version }}"
          CURRENT_MAJOR_MINOR="${{ steps.current.outputs.major_minor }}"
          
          echo "Searching for previous release PR..."
          
          # Get all merged PRs to main, sorted by merge date (newest first)
          PREVIOUS_RELEASE_PR=""
          PREVIOUS_VERSION=""
          PREVIOUS_MAJOR_MINOR=""
          
          # Search for the most recent release PR before current one
          gh pr list \
            --state merged \
            --base main \
            --limit 100 \
            --json number,title,mergedAt,url \
            --jq 'sort_by(.mergedAt) | reverse | .[] | select(.number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > prs.txt
          
          while IFS='|' read -r pr_num pr_title pr_url; do
            # Check if this PR is a release PR (not internal)
            if [[ "$pr_title" =~ ^[Rr][Ee][Ll][Ee][Aa][Ss][Ee] ]] && ! [[ "$pr_title" =~ ^[Ii][Nn][Tt][Ee][Rr][Nn][Aa][Ll] ]]; then
              PREVIOUS_RELEASE_PR="$pr_num"
              PREVIOUS_VERSION=$(echo "$pr_title" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+')
              PREVIOUS_MAJOR_MINOR=$(echo "$PREVIOUS_VERSION" | grep -oE '^[0-9]+\.[0-9]+')
              echo "Found previous release: PR #$PREVIOUS_RELEASE_PR - $PREVIOUS_VERSION"
              break
            fi
          done < prs.txt
          
          # Determine if this is a new major/minor version
          if [ -z "$PREVIOUS_MAJOR_MINOR" ]; then
            echo "is_new_version=true" >> $GITHUB_OUTPUT
            echo "This is the first release"
          elif [ "$CURRENT_MAJOR_MINOR" != "$PREVIOUS_MAJOR_MINOR" ]; then
            echo "is_new_version=true" >> $GITHUB_OUTPUT
            echo "New version detected: $PREVIOUS_MAJOR_MINOR -> $CURRENT_MAJOR_MINOR"
          else
            echo "is_new_version=false" >> $GITHUB_OUTPUT
            echo "Same version family: $CURRENT_MAJOR_MINOR"
          fi
          
          echo "previous_pr=$PREVIOUS_RELEASE_PR" >> $GITHUB_OUTPUT
          echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT

      - name: Collect PRs for this version
        id: prs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CURRENT_PR_NUMBER="${{ steps.current.outputs.number }}"
          CURRENT_MAJOR_MINOR="${{ steps.current.outputs.major_minor }}"
          IS_NEW_VERSION="${{ steps.collect.outputs.is_new_version }}"
          
          echo "Collecting PRs for version $CURRENT_MAJOR_MINOR..."
          
          # If this is a NEW version, only get PRs since last release
          # If SAME version, get ALL PRs for this version from the beginning
          
          if [ "$IS_NEW_VERSION" = "true" ]; then
            # NEW VERSION: Get PRs between last release and current
            PREVIOUS_PR_NUMBER="${{ steps.collect.outputs.previous_pr }}"
            echo "New version - collecting PRs since #$PREVIOUS_PR_NUMBER"
            
            if [ -n "$PREVIOUS_PR_NUMBER" ]; then
              gh pr list \
                --state merged \
                --base main \
                --limit 500 \
                --json number,title,url \
                --jq '.[] | select(.number > '$PREVIOUS_PR_NUMBER' and .number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > between_prs.txt
            else
              # First release ever
              gh pr list \
                --state merged \
                --base main \
                --limit 500 \
                --json number,title,url \
                --jq '.[] | select(.number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > between_prs.txt
            fi
          else
            # SAME VERSION: Need to get ALL PRs for this entire version family
            echo "Same version - collecting ALL PRs for version $CURRENT_MAJOR_MINOR"
            
            # Find the FIRST release PR for this major.minor version
            FIRST_RELEASE_PR=""
            gh pr list \
              --state merged \
              --base main \
              --limit 500 \
              --json number,title,mergedAt \
              --jq 'sort_by(.mergedAt) | .[] | "\(.number)|\(.title)"' > all_prs.txt
            
            while IFS='|' read -r pr_num pr_title; do
              if [[ "$pr_title" =~ ^[Rr][Ee][Ll][Ee][Aa][Ss][Ee] ]] && ! [[ "$pr_title" =~ ^[Ii][Nn][Tt][Ee][Rr][Nn][Aa][Ll] ]]; then
                VERSION=$(echo "$pr_title" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\+[0-9]+')
                MAJOR_MINOR=$(echo "$VERSION" | grep -oE '^[0-9]+\.[0-9]+')
                
                if [ "$MAJOR_MINOR" = "$CURRENT_MAJOR_MINOR" ]; then
                  FIRST_RELEASE_PR="$pr_num"
                  echo "Found first release for $CURRENT_MAJOR_MINOR: PR #$FIRST_RELEASE_PR"
                  break
                fi
              fi
            done < all_prs.txt
            
            # Get all PRs from first release of this version to current
            if [ -n "$FIRST_RELEASE_PR" ]; then
              gh pr list \
                --state merged \
                --base main \
                --limit 500 \
                --json number,title,url \
                --jq '.[] | select(.number > '$FIRST_RELEASE_PR' and .number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > between_prs.txt
            else
              # Fallback: get PRs from last release
              PREVIOUS_PR_NUMBER="${{ steps.collect.outputs.previous_pr }}"
              gh pr list \
                --state merged \
                --base main \
                --limit 500 \
                --json number,title,url \
                --jq '.[] | select(.number > '$PREVIOUS_PR_NUMBER' and .number < '$CURRENT_PR_NUMBER') | "\(.number)|\(.title)|\(.url)"' > between_prs.txt
            fi
          fi
          
          # Filter out internal PRs and collect normal PRs
          > normal_prs.txt  # Create empty file
          
          while IFS='|' read -r pr_num pr_title pr_url; do
            # Skip internal PRs
            if [[ "$pr_title" =~ ^[Ii][Nn][Tt][Ee][Rr][Nn][Aa][Ll] ]]; then
              echo "Skipping internal PR #$pr_num: $pr_title"
              continue
            fi
            
            # Skip release PRs
            if [[ "$pr_title" =~ ^[Rr][Ee][Ll][Ee][Aa][Ss][Ee] ]]; then
              continue
            fi
            
            # Add to file (one per line)
            echo "$pr_num|$pr_title|$pr_url" >> normal_prs.txt
          done < between_prs.txt
          
          # Count PRs
          PR_COUNT=$(wc -l < normal_prs.txt | tr -d ' ')
          echo "Found $PR_COUNT normal PRs"
          echo "pr_count=$PR_COUNT" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG.md
        run: |
          CURRENT_VERSION="${{ steps.current.outputs.version }}"
          CURRENT_PR_URL="${{ steps.current.outputs.url }}"
          CURRENT_MAJOR_MINOR="${{ steps.current.outputs.major_minor }}"
          IS_NEW_VERSION="${{ steps.collect.outputs.is_new_version }}"
          PREVIOUS_VERSION="${{ steps.collect.outputs.previous_version }}"
          REPO="${{ github.repository }}"
          
          # Create CHANGELOG.md if it doesn't exist
          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
          fi
          
          export CURRENT_VERSION
          export CURRENT_PR_URL
          export IS_NEW_VERSION
          export PREVIOUS_VERSION
          export REPO
          
          python3 << 'PYTHON_SCRIPT'
          import re
          import os
          
          current_version = os.environ.get('CURRENT_VERSION')
          current_pr_url = os.environ.get('CURRENT_PR_URL')
          is_new_version = os.environ.get('IS_NEW_VERSION')
          previous_version = os.environ.get('PREVIOUS_VERSION')
          repo = os.environ.get('REPO')
          
          # Read the CHANGELOG
          with open('CHANGELOG.md', 'r') as f:
              content = f.read()
          
          # Read the collected PRs
          pr_entries = []
          try:
              with open('normal_prs.txt', 'r') as f:
                  for line in f:
                      line = line.strip()
                      if not line:
                          continue
                      parts = line.split('|')
                      if len(parts) >= 3:
                          pr_num = parts[0]
                          pr_url = parts[2]
                          pr_title = '|'.join(parts[1:-1]) if len(parts) > 3 else parts[1]
                          pr_entries.append(f"- [{repo}#{pr_num}]({pr_url}) {pr_title}")
          except FileNotFoundError:
              pass
          
          # Reverse to show newest first
          pr_entries.reverse()
          
          # Extract major.minor for the version label
          major_minor = '.'.join(current_version.split('.')[:2])
          
          # Check if this is a new major.minor version
          if is_new_version == 'true':
              # Create NEW version section with heading format: ### [version](url) Version X.Y
              new_section = f"### [{current_version}]({current_pr_url}) Version {major_minor}\n"
              if pr_entries:
                  new_section += "\n".join(pr_entries) + "\n"
              
              # Check if we already have content
              if content.strip() == "# Changelog":
                  # First release
                  content = f"# Changelog\n\n{new_section}\n"
              else:
                  # Insert after the title
                  content = re.sub(
                      r'(# Changelog\s*\n)',
                      r'\1\n' + new_section + '\n',
                      content,
                      count=1
                  )
          else:
              # Same major.minor version - REPLACE existing section with updated data
              # The workflow already collected ALL PRs for this version, so just replace
              version_pattern = rf'### \[[^\]]+\]\([^)]+\) Version {re.escape(major_minor)}'
              
              # Build the updated section with all PRs
              updated_section = f"### [{current_version}]({current_pr_url}) Version {major_minor}\n"
              if pr_entries:
                  updated_section += "\n".join(pr_entries) + "\n"
              
              if re.search(version_pattern, content):
                  # Replace the existing section completely
                  content = re.sub(
                      rf'### \[[^\]]+\]\([^)]+\) Version {re.escape(major_minor)}\n(?:- \[.*?\n)*',
                      updated_section,
                      content,
                      count=1
                  )
              else:
                  # Version section doesn't exist, create it
                  content = re.sub(
                      r'(# Changelog\s*\n)',
                      r'\1\n' + updated_section + '\n',
                      content,
                      count=1
                  )
          
          with open('CHANGELOG.md', 'w') as f:
              f.write(content)
          
          print(f"âœ“ Added release {current_version} with {len(pr_entries)} PRs")
          PYTHON_SCRIPT

      - name: Commit and push changes
        run: |
          git add CHANGELOG.md
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          git commit -m "chore: update CHANGELOG for release ${{ steps.current.outputs.version }}" -m "Co-Authored-By: Warp <agent@warp.dev>"
          
          # Only push if not running in act (local testing)
          if [ -z "$ACT" ]; then
            git push origin main
          else
            echo "Running in act - skipping push"
            echo "Changes committed locally:"
            git log -1 --stat
          fi
